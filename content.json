{"meta":{"title":"YMJ's Blog","subtitle":"Share Ideas","description":"stay hungry stay foolish","author":"于梦娇","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"python 函数","slug":"function","date":"2018-10-13T07:14:12.058Z","updated":"2018-10-13T07:13:20.118Z","comments":true,"path":"2018/10/13/function/","link":"","permalink":"http://yoursite.com/2018/10/13/function/","excerpt":"","text":"Python 函数写程序六个字原则:高内聚 低耦合(high cohesion low coupling) 高内聚:写一个函数只做好一件事情低耦合:一个函数尽量不要跟其他函数绑在一起 123456def calc(items, fn): &quot;&quot;&quot;计算函数,将+,-,*,/运算与函数解耦合&quot;&quot;&quot; result = items[0] for item in range(1, len(items)): result = fun(result, items[index]) return result 在python中函数是一等公民,函数可以赋值给变量,可以作为方法的参数和返回值自定义规则就是解耦合操作 生成器() 浪费时间,调一次计算一次 存的是数据的产生方式,是一种算法生成式[] 浪费空间 时间和空间是无法兼具的 12345678910111213141516五个人分鱼,A把鱼分成5份,扔掉了多余的一条,拿走其中的一份,B把剩下的鱼又分成5份,扔掉多余的一条,拿走一份,C,D,E操作相同,问这堆鱼最少有多少条?fish = 0while True: enough = True amount = fish for _ in range(5): if (amount - 1) % 5 == 0: amount = (amount - 1) // 5 * 4 else: enough = False break if enough: print(fish) break fish += 1 函数中的参数123456*args-可变参数 元祖 不知道参数个数可以通过args对参数打包 *作用是打包**kwargs-关键字参数keyword arguments 字典 函数接收带参数名和参数值的参数def foo3(a, *, b, c): return a + b + c*前面的参数是位置参数,传参时可以不用指定参数名*后面的参数是命名关键字参数,传参时必须指定参数名,否则报错 递归函数经典问题:骑士周游问题汉洛塔八皇后问题 1234567891011汉洛塔问题def move(num, a, b, c): #把n-1个盘子从a搬到c move(num-1, a, c, b) #把最大的盘子从a搬到b print(f&apos;&#123;a&#125;----&gt;&#123;b&#125;&apos;) #把n-1个盘子从c搬到b move(num - 1, c, b, a) num = int(input(&apos;盘子个数:&apos;))move(num, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;) 1234567891011121314151617181920212223242526272829303132斐波那契数列(优化)def fib(num, temp=&#123;&#125;): if num in (1, 2): return 1 try: return temp[num] except KeyError: temp[num] = fib(num - 1) + fib(num - 2) return temp[num] def fib2(num): a, b = 1, 1 for _ in range(num - 1): a, b = b, a+b return a 上楼梯(优化)def walk(num, temp=&#123;&#125;): if num &lt;= 0: return 1 if num == 0 else 0 try: return temp[num] except KeyError: temp[num] = walk(num - 1) + walk(num - 2) + walk(num - 3) return temp[num]def walk2(num): s1, s2, s3 = 1, 2, 4 for _ in range(num - 1): s1, s2, s3 = s2, s3, s1 + s2 + s3 return s1 爬楼梯思想 当有一个10层的楼梯,一次可以爬一层或两层,首先可以先假设一下: 爬1层—1种方法 爬2层—2种方法 爬3层—3种方法 爬4层—5种方法 爬5层—8种方法 … 可以看出规律是an = an-1 + an-2,那么到第十层的方法数就是到第九层方法数加上到第八层的方法数,以此类推 总结 递归函数最重要的就是: 1.找到递推规律2.找到收敛条件,知道什么时候让函数结束 ##装饰器函数 装饰器函数是用一个函数装饰另一个函数,给它增加额外的功能,而不需要书写重复的代码. 装饰器函数的参数是被装饰的函数,返回的是起装饰作用的函数 调用被装饰的函数时,其实执行的是装饰器中返回的函数 函数添加装饰器的语法就是在函数前写上@装饰器函数 1234567891011121314151617181920import timedef record(fn): def wrapper(*args, **kwargs): start = time.time() ret_value = fn(*args, **kwargs) end = time.time() print(f&apos;&#123;end - start&#125;秒&apos;) return ret_value return wrapper @recorddef fac(num): result = 1 for n in range(1, num + 1): result *= n return result #装饰器的本质是执行了下面的代码 # fac = record(fac) 面向对象面向对象有三步: 1.定义类-把同类型公共的事物总结出共同特征 (1)数据抽象:找到和对象相关的属性,找名词 (2)行为抽象:找方法,找动词 2.创建对象 3.给对象发消息,让对象做事情 共同的属性和行为写在父类中,特有的写在子类中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from abc import ABCMeta, abstractmethod#把类声明成抽象类class Employee(metaclass=ABCMeta): def __init__(self, name): self.name = name @abstractmethod //说明这个方法是抽象方法,装饰器,要求子类必须实现 def salary(self): pass class Manager(Employee): @property//把方法改成属性 def salary(self): return 15000 class Programmer(Employee): def __init__(self, name): self.name = name slef.work = 0 @property def salary(self): return 200 * self.work class Salesman(Employee): def __init__(self, name): self.name = name self.sale = 0 @property def salary(self): return 1800 + self.sale * 0.05 def main(): emps=[ Manager(&quot;刘备&quot;), Manager(&quot;曹操&quot;), Programmer(&quot;诸葛亮&quot;), Programmer(&quot;荀彧&quot;), Salesman(&quot;貂蝉&quot;) ] for emp in emps: #isinstance函数可以在运行时进行类型识别 if isinstance(emp, Programmer): emp.work = int(input(f&apos;请输入&#123;emp.name&#125;本月工作时间:&apos;)) elif isinstance(emp, Salesman): emp.sale = int(input(f&apos;请输入&#123;emp.name&#125;本月销售额:&apos;)) print(&apos;%s: %.2f元&apos; % (emp.name, emp.salary)) if __name__ == &apos;__main__&apos;: main() 重写:子类把父类已经有的方法重新实现一遍,不同的子类给出不同的实现版本,就可以实现多态 多态:同样的方法,干的事情不同","categories":[],"tags":[]},{"title":"Linux","slug":"Linux","date":"2018-10-13T07:14:12.057Z","updated":"2018-10-13T02:36:43.670Z","comments":true,"path":"2018/10/13/Linux/","link":"","permalink":"http://yoursite.com/2018/10/13/Linux/","excerpt":"","text":"Linux 系统基础命令Linux概述 Linux是一个通用操作系统,是C语言编写的,比windows操作系统优于其可靠的安全性和稳定性,支持多用户和多任务,拥有大量的实用程序和强大的支持文档. www.kernel.org 是Linux的内核下载网站 基础命令 获取登录信息- 看到用户登陆的信息 1w/who/who am i ​ 查看自己使用的Shell 123ps(查看进程)kill PID(结束进程)kill -9 PID(强行结束进程) Shell也被称为“壳”，它是用户与内核交流的翻译官，简单的说就是人与计算机交互的接口。目前很多Linux系统默认的Shell都是bash（Bourne Again Shell），因为它可以使用Tab键进行命令补全、可以保存历史命令、可以方便的配置环境变量以及执行批处理操作等。 查看命令的说明 1whatis 查看帮助文档 123man ps-打开命令的使用手册info ps-给程序员看的 ps --help 切换用户 1234su(switch user)sudo(super user do)-普通用户以超级管理员身份执行#命令行提示符-超级管理员$-普通用户 登入登出 12345adduser-创建新用户passwd-设置密码exit-退出登录log outuserdel-删除用户 重启和关机 12345shutdown-关机shutdown -c 取消关机init 0 关机reboot-重启init 6 重启 查看历史命令 123history-查看所有历史命令 上下键可以查看历史命令history -c 清空历史命令!30-执行第30行的历史命令 实用程序 创建/删除文件夹 123mkdir-make directories-创建文件夹rmdir-remove empty directories-删除空文件夹mkdir -p(parents上一级目录也会创建) 创建/删除文件 123touch/rmtouch readme.txt 创建文件名为readme的文本文件rm -rf ./* 删除当前文件夹里所有文件 touch 命令用于创建空白文件或修改文件时间 rm重要参数有 -i:交互式删除 -r:删除目录并递归的删除目录中的文件和目录 -f:强制删除 切换和查看当前工作目录 12cd-change directory -改变所在目录pwd-print current working-查看当前工作目录 1234&gt;cd命令后面可以跟相对路径（以当前路径作为参照）或绝对路径（以/开头）来切换到指定的目录，也可以用cd ..来返回上一级目录。&gt;/系统根目录相当于我的电脑&gt;~用户主目录&gt; 查看目录内容-ls ls(list directory contents) -l：以长格式查看文件和目录。-a：显示以点开头的文件和目录（隐藏文件）。-R：遇到目录要进行递归展开（继续列出目录下面的文件和目录）。-d：只列出目录，不列出其他内容。-S/-t：按大小/时间排序。 查看文件内容-cat/head/tail/more/less 1234cat -n(行号:命令的参数)concatnate-连接多个文件并显示到标准输出上./当前目录../父级目录/根目录 拷贝/移动文件 123456cp-copy files and directoriesmv-move 可以改名字cp index.htm abc/efg/(文件名不变)cp index.html ../拷贝到上一级目录,文件重名会有提示是否覆盖cp -r(递归) abc /usr/hello 拷贝文件夹,名字hellocp -r(递归) abc /usr/hello/ 名字没变,到hello文件夹下面去了 查找文件和查找内容 12find-查找文件grep-查找内容 ​ 链接 1-ln ​ 说明：链接可以分为硬链接和软链接（符号链接）。硬链接可以认为是一个指向文件数据的指针，就像Python中对象的引用计数，每添加一个硬链接，文件的对应链接数就增加1，只有当文件的链接数为0时，文件所对应的存储空间才有可能被其他文件覆盖。我们平常删除文件时其实并没有删除硬盘上的数据，我们删除的只是一个指针，或者说是数据的一条使用记录，所以类似于“文件粉碎机”之类的软件在“粉碎”文件时除了删除文件指针，还会在文件对应的存储区域填入数据来保证文件无法再恢复。软链接类似于Windows系统下的快捷方式，当软链接链接的文件被删除时，软链接也就失效了。 压缩/解压缩和归档/解归档 123456gzip-压缩gunzip-解压缩 g表示遵循开源协议xz-压tar-归档文件-把多个文件合并成一个文件 -解归档-把一个文件拆成多个文件tar -x(extract)v(看到过程)f(文件名) 其他工具 1234567891011121314151617181920212223242526272829301.echoecho &quot; print &apos; hello,world&apos;&quot; &gt; hello.py&gt;输出重定向&gt;&gt;追加重定向,把新的内容追加到原来内容的后面重定向时文件没有会自动创建新文件echo $a-返回a的值echo $[a+b]-返回a+b的结果2.alias命令的别名unalias rmd 删除起的别名3.wget通过网络下载文件命令4.ls --help | more 前面指令的输出是后面指令的输入|管道(进程间通信)-把前一个进程的输出当成后一个进程的输入进程之间通信方式:管道|,套接字5.wcword count统计6.uniq-unique-去重7.sort排序 先排序后去重8.diff 比较两个文件哪里不一样9.chmod-改变文件模式chmod u+x g+x o+xchmod 75510.chown-改变所有者11.发消息write 用户名,输入结束后按ctrl+d不接受消息-mesg n接收消息-mesg ywall-write all给所有人发消息 ​ ​ 目录结构 /bin - 基本命令的二进制文件。 /boot - 引导加载程序的静态文件,系统启动。 /dev - 设备文件。 /etc - 配置文件。 /home - 普通用户主目录的父目录。 /lib - 共享库文件。 /lib64 - 共享64位库文件。 /lost+found - 存放未链接文件。 /media - 自动识别设备的挂载目录。 /mnt - 临时挂载文件系统的挂载点。 /opt - 可选插件软件包安装位置。 /proc - 内核和进程信息。 /root - 超级管理员用户主目录。 /run - 存放系统运行时需要的东西。 /sbin - 超级用户的二进制文件。 /sys - 设备的伪文件系统。 /tmp - 临时文件夹。 /usr - 用户应用目录。 /usr/bin 放指令的 /usr/local 安装软件 /var - 变量数据目录。 ​ 安装软件 使用包管理工具 yum - Yellow dog Updater Modified。 yum search：搜索软件包，例如yum search nginx。 yum list installed：列出已经安装的软件包，例如yum list installed | grep zlib。 yum install：安装软件包，例如yum install nginx。 yum remove：删除软件包，例如yum remove nginx。 yum update：更新软件包，例如yum update可以更新所有软件包，而yum update tar只会更新tar。 yum check-update：检查有哪些可以更新的软件包。 yum info：显示软件包的相关信息，例如yum info nginx。 rpm - Red hat Package Manager。 ​ Cent OS安装Python 3.7 1.下载python源代码 1wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz ​ 2.解压缩 1gunzip Python-3.7.0.tgz ​ 3.解归档 1tar -xvf Python-3.7.0.tar ​ 4.安装底层依赖库 yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 5.安装前的配置 1/root/Python-3.7.0./configure --prefix=/usr/local/python37 --enable-optimizations 6.make &amp;&amp; make install 构建安装 &amp;&amp; 前的执行完,后面再执行,如果前面错误,后面也不执行 7.配置PATH环境变量 1export PATH=$PATH:/usr/local/python37/bin $PATH:读取原有的path路径 8.注册软链接(符号链接) 1ln -s /usr/local/python37/bin/python3.7 /usr/bin/python3 ​ ​ vim-文本编辑神器 命令模式—&gt;编辑模式 i(insert),a(append) 编辑模式 —&gt; 命令模式 esc 命令模式 —&gt; 末行模式 : / ? ​ 移动光标 hjkl结合数字 HML H:第一行一列 M:中间一列 L:屏幕最后一行 0 行首 $ 行尾 w 下一个单词 gg 文章开头 G 文章结尾 翻页 1234ctrl+e-往下翻一行ctrl+y-往上翻一行ctrl+f-往下翻一页ctrl+b-往上翻一页 其他操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 yy-复制 p-粘贴 dd-删除 u-撤销 ctrl+r-重做上一个动作 ctrl+x ctrl+o - 代码提示 chmod u(user)+x(x执行权限) 改变模式 :w :q :qa - 退出全部窗口 :set nu :set ts=4 :set autoindent 自动缩进 :1,$s/被替换的内容/替换后的内容/gice -g: 全局模式 -i: 忽略大小写 -c: 确认模式 -e: 忽略错误 /正则表达式 - 正向搜索 n - 正向搜索 N - 反向搜索 ?正则表达式 - 反向搜索如果vim打开了多个文件可以在末行模式中通过 :b &lt;编号&gt; 切换到其他文件 :ls - 查看打开的文件拆分窗口 :vs 垂直拆分 :sp 水平拆分 ctrl+w ctrl+w - 在窗口之间切换光标设置快捷键 :imap-输入模式下的快捷键 :inoremap-不要递归的map想拿到命令行参数 在py文件中插入import sys sys.argv可以拿到命令行参数 三元条件运算符: y = year if 条件1 else 条件二 命令mount挂载u盘 umount反挂载 执行命令,把命令的执行结果赋给变量username=`whoami`命令之间用;隔开-一个一个执行用&amp;&amp;隔开-前面成功了后面才执行||-前面不成功才执行后面的 Nginx服务器 ​ 1234567891011121314151617一. Nginx是一个http服务器。是一个使用c语言开发的高性能的http服务器及反向代理服务器。二. Nginx 应用场景 1、 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 2、 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 - 基于端口的，不同的端口 - 基于域名的，不同域名 3、 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需 要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为 某台服务器负载高宕机而某台服务器闲置的情况。三. 使用Nginx: systemctl start nginx nginx 首页html文件放在/usr/share/nginx/html里 ### 网络访问和管理 ​ 1234567891011121314151617181920212223242526271.通过网络获取资源-wget2.显示/操作网络配置(旧)-ifconfig if:interface 网络端口的配置查看Linux系统中的IP地址 显示/操作网络配置(新)-ip3.网络可达性检查-pingping www.baidu.com4.查看网络服务和端口-netstatnetstat -nap | grep nginxn(number)a(all)p(process)5.安全远程连接-sshssh root@别人的公网IP连接到别人的服务器6.安全文件拷贝-scpscp 文件名 root@IP地址:/root/新文件名7.安全文件传输-sftpsftp root@别人公网IP下载文件-get上传文件-put看自己系统的目录 lls退出 quit/bye | 计算机网络分层架构模型 | | | —————————— | ——- | | Internet | TCP/IP | | TCP(transfer control protocol) | 传输控制协议 | | UDP(user datagram protocol) | 用户数据报协议 | | IP(Internet protocol) | 网际协议 | 1234567891011121314151617181920212223242526272829ip地址找到网络上的一台主机，而端口号可以用来区分不同的服务； HTTP - 80 HTTPS - 443端口号： -1 ： 可以使用ping 22 ： 可以使用远程连接Xshell 3389: 监控Linux常用防火墙服务Firewall和Iptables自己配防火墙 ,在阿里云APP里的安全组规则,新建一个,协议选TCP,端口设置1-65535 增加端口firewall-cmd --add-port=80/tcp--permanent查看端口firewall-cmd --query-port=80/tcp将自己的项目克隆到服务器上： - 1、git clone http://gitee.com/jackfrued/Python1806 - 2、将本地的项目上传（通过Xftp) TCP/IP模型应用层(定义应用之间如何传输数据,定义应用级协议) -HTTP/SMTP/POP3/FTP/SSH -ICQ/QQ传输层(端到端传输数据)- TCP/UDP网络层/网际层(寻址和路由)-IP/ICMP物理链路层(数据分帧+校验)-冗余校验码 进程管理 查询进程 12ps -ef标准格式查看所有进程 终止进程 12kill -9强制终止 将进程置于后台 ctrl+Z &amp; 如果执行命令时在命令后加上&amp;就可以将命令置于后台运行 进程转换 12bg %编号-让暂停的进程继续在后台运行fg %编号-让后台进程拿到前台运行 进程监控 12按CPU占用率从高到低排列进程-top查询后台进程-jobs 配置服务1.启动服务 1systemctl start firewall 2.终止服务 1systemctl stop firewall 3.重启服务 1systemctl restart firewall 4.查看服务 1systemctl status firewall 5.设置是否开机自启动 12systemctl enable firewall-开机自启动systemctl disable firewall-禁止开机自启动 ​","categories":[],"tags":[]},{"title":"JavaScript 语法","slug":"JavaScript-grammer","date":"2018-10-05T16:00:00.000Z","updated":"2018-10-06T09:25:27.668Z","comments":true,"path":"2018/10/06/JavaScript-grammer/","link":"","permalink":"http://yoursite.com/2018/10/06/JavaScript-grammer/","excerpt":"","text":"JavaScriptJavaScript 是 Web 的编程语言。 所有现代的 HTML 页面都使用 JavaScript。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495961.注释 单行注释在前面加//,多行注释/**/2.标识符 数字,字母,下划线和$符组成,数字不能开头,大小写敏感3.基本数据类型 Number(数字-包含所有的数字) Boolean(布尔类型) String(字符串) Array(数组) Object(对象) NaN(不存在的数字),null(空),undefined(变量没有赋值的时候)4.字面量 Number:所有的数字 Boolean字面量:只有true和false String字符串:用单引号或者双引号引起来的字符集 Array字面量:相当于python中的列表 Object对象字面量:key相当于属性名,value相当于属性值 相当于python中的字典加对象 typeof:查看数据类型 字面量是一个恒定的值5.js中的语句:a.一条语句结束后可以写分号,也可以不写,如果一行写多条语句就必须写分号b.js中没有缩进语法要求,需要使用代码块的时候使用&#123;&#125;6.变量的声明 var 变量名=初值 驼峰式命名7.运算符 数学运算符,比较运算符,逻辑运算符,赋值运算符,三目运算符 数学运算符:+、-、*、/、%、**(js7中才有的)、++、-- 比较运算符:&gt;,&lt;,==,!=,&gt;=, &lt;=, ===, !==, &gt;==, &lt;== 相等(==):只判断值是否相等 完全相等(===):判断值和类型是否相等 逻辑运算符：&amp;&amp;(与)，||(或), !(非) 赋值运算符：=， += ，-=， *=， /=， %= 语法：表达式1?值1:值2 ---&gt; 判断表达式1的值是否为真，为真整个 运算的结果就是值1，否则是值28.分支结构 (1)if语句 if(条件语句)&#123; 代码段 &#125; if(条件语句)&#123; 代码段1 &#125;else&#123; 代码段2 &#125; if(条件语句1)&#123; 代码段1 &#125;else if(条件语句2)&#123; 代码段2 &#125;else&#123; 代码段3 &#125; (2)switch语句 switch(表达式)&#123; case 值1:&#123; 代码段1 &#125; case 值2:&#123; 代码段2 &#125; ... default:&#123; 代码段3 &#125; 执行过程:先计算表达式的值，然后再用这个值去和后边case关键字后面的值一一对比，看是否相等。找到第一个和表达式的值相等的case,然后将这个case作为入口，一次执行后边所有的代码，直到遇到break或者switch结束。如果没有找到和表达式的值相等的case就执行default后面的代码.default可有可无，case可以有若干个9.循环结构 (1)for循环 for(var 变量 in 序列)&#123; 循环体 &#125; for(表达式1；表达式2；表达式3)&#123; 循环体 &#125; 先执行表达式1，然后再判断表达式2的结果是否为true,如果为true，就执行循环体。执行完循环体再执行表达式3。然后再判断表达式2的结果是否为true，依次循环，知道表达式2的结果为false为止 (2)while循环 while(条件语句)&#123; 循环体 &#125; do&#123; 循环体 &#125;while(条件语句) 先执行一次循环体，然后再判断条件语句是否为true,为true又执行循环体，依次类推，直到条件语句为false，循环就结束10.函数 function 函数名(参数列表)&#123; 函数体 &#125; 注意：js中不能同时返回多个值（有元祖语法的语言才支持多个返回值） js中，函数也可以作为变量11.数据类型new 类型名(值) ---&gt; 可以将其他的类型的数据转换成相应类型的值1.数字类型(Number)：不能转换的结果是NaN2.布尔(Boolean):所有为0为空的转换成布尔是false，如NaN,null和undefined都是false;其他的都是true3.字符串(String):unicode编码获取单个字符：通过字符串[下标]js中的下标支持0到长度-1，不支持负值,不支持切片4.数组 有序，可变的，元素的类型可以是任意类型的数据增:数组.push() 删:数组.pop()删除最后一个元素 数组.shift()删除第一个元素 splice(删除的开始下标, 删除的元素的个数)splice(被删除的下标/添加的开始下标, 添加个数, 被添加的元素列表)","categories":[],"tags":[]},{"title":"JS","slug":"DOM,BOM","date":"2018-10-05T16:00:00.000Z","updated":"2018-10-06T09:54:23.080Z","comments":true,"path":"2018/10/06/DOM,BOM/","link":"","permalink":"http://yoursite.com/2018/10/06/DOM,BOM/","excerpt":"","text":"当网页被加载时，浏览器会创建页面的文档对象模型. 浏览器对象模型 使 JavaScript 有能力与浏览器”对话”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293JavaScript = ECMAScript + BOM +DOMBOM-浏览器对象模型-windowDOM-文档对象模型-document1.显示数据a. window.alert()b. document.write()如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。c. innerHTML写入HTML元素d. console.log()2.对象JS对象是拥有属性和方法的数据,JS对象是变量的容器,是属性和方法的容器3.作用域作用域为可访问的变量,对象,函数的集合HTML DOM(文档对象模型)- JavaScript 能够改变页面中的所有 HTML 元素- JavaScript 能够改变页面中的所有 HTML 属性- JavaScript 能够改变页面中的所有 CSS 样式- JavaScript 能够对页面中的所有事件做出反应通常，通过 JavaScript，需要操作 HTML 元素,必须首先找到该元素。有五种方法来做这件事：4.获取元素- 通过 id 找到 HTML 元素 document.getElementById- 通过标签名找到 HTML 元素 document.getElementsByTagName- 通过类名找到 HTML 元素 document.getElementsByClassName- 返回匹配的指定 CSS 选择器的一个元素document.querySelector() - 返回文档中匹配的CSS选择器的所有元素节点列表 document.querySelectorAll() 返回 NodeList 对象。 NodeList对象表示节点的集合,可以通过索引访问，索引值从0开始。元素访问子节点-children元素访问父节点-parentNode元素访问兄弟节点-previousSibling/nextSibling5.操作元素 改变HTML的内容-元素.innerHTML,元素.textContent 改变HTML的属性-元素.attribute例:image.src=&quot;新图片的名字&quot; 更改图片 改变HTML的样式-元素.style.具体样式(如color) style属性只能写不能读,读样式通过currentStyle,读出来的值带px 删除元素style.display = &quot;none&quot; style.visibility = &quot;hidden&quot; 创造一个标签:document.createElement(),createTextNode() 6.JS中的事件处理- (1)在标签上使用on...属性来进行事件绑定- (2)通过代码获取标签绑定on...属性- (3)通过代码获取标签然后使用addEventListener() 方法 addEventListener() 方法用于向指定元素添加事件句柄,添加的事件句柄不会覆盖已存在的事件句柄,可以向一个元素添加多个事件句柄,可以向同个元素添加多个同类型的事件句柄，如：两个 &quot;click&quot; 事件。 可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。 当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。 可以使用 removeEventListener() 方法来移除事件的监听。 语法 element.addEventListener(event, function, useCapture);第一个参数是事件的类型 (如 &quot;click&quot; 或 &quot;mousedown&quot;).第二个参数是事件触发后调用的函数。- 绑定事件监听器的函数都需要传入事件的回调函数- 程序员知道事件发生的时候需要做什么样的处理,但是不知道事件什么时候发生- 所以传入一个函数在将来发生事件的时候由系统进行调用 ,这种函数就称为回调函数- 回调函数的第一个参数代表事件对象(封装了所有和事件相关的信息) 对于低版本的IE 通过window.event来获取事件对象-事件对象的属性和方法: - target/srcElement - 事件源(引发事件的标签) - preventDefault()/returnValue = False(IE) - 阻止事件默认行为第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。 事件传递有两种方式：冒泡与捕获。事件传递定义了元素事件触发的顺序。在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即从里向外. 在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即从外向里。 如果要阻止事件的传播行为(阻止事件冒泡)可以使用stopPropagation() / cancelBubble = true (IE)7.添加/删除元素 在文档中添加元素用 父.appendChild(子) 方法 它用于添加新元素到尾部。如果我们需要将新元素添加到开始位置，可以使用 insertBefore() 方法. 父.insertBefore(子,父.firstChild) 在文档中删除元素用父.removeChild(子) 在文档中替换元素用父.replaceChild(替换元素,被替换元素) 123456789101112131415161718192021222324252627282930313233 浏览器对象模型 (BOM) 浏览器对象模型 (Browser Object Model (BOM)) 使 JavaScript 有能力与浏览器&quot;对话&quot;。 可以在JS中创建三种消息框:警告框,确认框,提示框. 警告框:window.alert() 确认框:window.confirm() 提示框:window.prompt() 用于提示用户在进入页面前输入某个值 (1)window.screen对象包含有关用户屏幕的信息screen.availWidth - 可用的屏幕宽度screen.availHeight - 可用的屏幕高度 (2)window.location对象用于获得当前页面的地址(URL),并把浏览器重定向到新的页面。location.hostname 返回 web 主机的域名location.pathname 返回当前页面的路径和文件名location.port 返回 web 主机的端口 （80 或 443）location.protocol 返回所使用的 web 协议（http:// 或 https://）location.href 属性返回当前页面的 URL。 (3)window.history对象包含浏览器的历史history.back() - 与在浏览器点击后退按钮相同history.forward() - 与在浏览器中点击向前按钮相同 (4)window.navigator 对象包含有关访问者浏览器的信息。浏览器代号: navigator.appCodeName 浏览器名称: navigator.appName浏览器版本: navigator.appVersion 启用Cookies: navigator.cookieEnabled 硬件平台: navigator.platform 用户代理: navigator.userAgent 用户代理语言: navigator.systemLanguage 计时器setInterval() - 间隔指定的毫秒数不停地执行指定的代码setTimeout() - 在指定的毫秒数后执行指定代码clearInterval() 方法用于停止 setInterval() 方法执行的函数代码。clearTimeout() 方法用于停止执行setTimeout()方法的函数代码。","categories":[],"tags":[]},{"title":"样式表内容","slug":"CSS","date":"2018-10-05T16:00:00.000Z","updated":"2018-10-06T09:50:06.652Z","comments":true,"path":"2018/10/06/CSS/","link":"","permalink":"http://yoursite.com/2018/10/06/CSS/","excerpt":"","text":"层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式通常存储在样式表中 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在 CSS 文件中 多个样式定义可层叠为一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869CSS是web标准中的表现标准,用来规定网页上内容的布局和样式(css又叫样式表),目前广泛使用的是CSS3 1.怎么来写样式表(CSS),写在哪儿 a.内联样式表: 将样式写在标签的style属性中(每个可见标签都有style属性) b.内部样式表 将样式表写在head标签中的style标签里面 c.外部样式表 将样式表写在一个CSS文件中,然后在head标签中通过link标签来导入 注意:不管在什么情况下,内联样式表的优先级最高 内部和外部的优先级看谁后写,谁的优先级高 2.固定语法 选择器&#123;属性1:属性值1;属性2:属性值2...&#125; 说明: a.选择器:选择器的作用是用来确定后面的样式到底是给哪些标签写的 b.属性:属性是CSS中本来就支持和拥有的属性,属性的顺序可以随便写 属性和属性值之间使用冒号连接 属性后面必须写分号 c.属性值: (1) 数值:如果数值是用来表示大小,后面必须跟单位px或% px---像素 %----百分比(前提是父标签对应的宽度或高度是确定的) (2)颜色: 颜色对应的英语单词 直接使用RGB值:rgb(R,G,B),rgba(R,G,B,Alpha透明度) R,G,B的取值范围是0-255,Alpha:0-1 3.常见的属性 color:设置字体的颜色 background-color:背景颜色 width:宽度 height:高度 font-size:字体大小 4.常用的选择器 (1)标签(元素)选择器 例:a&#123;&#125;---选中所有的a标签 (2)id选择器 #p1&#123;&#125;-----选中id值是p1的标签 (3)class选择器 .c1----选中所有class值是c1的标签 (4)群组选择器:多个选择器中间使用逗号隔开 (5)包含选择器:多个选择器之间用空格隔开 div .c1 p&#123;&#125;---选中div中class是c1的标签中的p标签 (6)通配符*:选中页面内所有标签,样式一般先作如下处理 *&#123; margin: 0; padding: 0; position: relative;&#125; 优先级遵循三条原则 就近原则,具体性原则(ID&gt;类&gt;标签[]&gt;标签&gt;通配符),重要性原则 5.伪类选择器 伪类选择器是选中标签的某个状态 (1)语法----标签:状态 说明: a.状态: link:初始状态(a标签对应的初始状态是没有访问成功过对应的状态) visited:访问后的状态(适用于a标签) hover:鼠标悬停在标签上对应的状态 active:超链接被激活---鼠标(按下)按住不放对应的状态 focus:成为焦点(在输入框中用的比较多) b.标签:可以是通过不同的选择器去选中 (2)爱恨原则:LoVeHAte-先爱后恨 如果想要给一个标签同时link,visited,hover,active中的两个或者两个以上的状态设置样式,必须遵守爱恨原则 (如果不按爱恨原则可能会出问题,如果按照爱恨原则肯定不会出问题) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455566.标准流 标准流:浏览器对标签默认的布局方式就是标准流 标准流布局原则: 块级:块级标签一个占一行(不管标签的宽度是否是父标签的宽度),默认宽度是父标签的宽度,默认高度是内容的高度,直接设置宽高有效 行内块标签:多个行内块可以在一行显示,默认宽高都是内容的宽高,直接设置宽高有效 行内标签(a标签):多个行内标签可以在一行显示,默认宽高都是内容的宽高,直接设置宽高无效 通过display属性来转换标签的性质block(块级),inline(行内),inline-block(行内块) 注意:行内块标签和其他标签之间默认有间隙,而且这个间隙无法消除7.浮动 通过给CSS中的属性float赋值为left或right,来让标签浮动,浮动会让标签脱离标准流,浮动的目的就是让竖着显示的可以横着显示(针对块) 所有的标签浮动后,一行可以显示多个,默认的宽高是内容的大小,可以设置宽度和高度,一行显示不了的时候才会自动换行 如果同一级的标签,后边的需要浮动,前面的也要浮动,否则可能会出现显示的问题,浮动的标签不占池底位置,只占水面的位置,不浮动的既占池底又占水面 文字环绕效果:被环绕的标签浮动,文字对应的标签不浮动8.清除浮动 清除浮动:清除浮动不是将标签的浮动给去掉,而是清除因为浮动而产生的高度塌陷的问题 高度塌陷:父标签不浮动,子标签浮动并且不设置父标签的高度,就会产生高度塌陷的问题(父标签) 方案一:添加空盒子,在高度塌陷的标签(父标签)的最后添加一个空的div,并且设置样式属性clear的值为both 方案二:给父标签添加样式设置overflow的值为hidden 方案三 #father:after&#123; display: block; clear: both; content: &apos;&apos;; visibility: hidden; height: 0; &#125; #father:after&#123; zoom: 1; &#125;9.定位 CSS中可以通过left,right,bottom,top属性来设置标签到上下左右的距离但是想要让定位属性有效,必须设置通过position属性设置参考对象position属性 initial:默认值,没有相对定位 absolute:相对于第一个非static/initial父标签进行定位 relative:相对于自己在标准流中的位置定位.想要将一个标签作为其他标签的参考对象,当标签本身不希望去定位,只是想让自己的子标签可以相对本身来定位的时候使用 fixed:相对于浏览器定位 sticky:当网页的内容不超过一屏(不滚动)的时候,就按照标准流定位.超过了就相对浏览器定位 如果想要设置right值要保证相对标签的宽度是确定的,如果想要设置bottom值要保证相对对象的高度是确定的 技巧:当遇到某个方向的定位死活都无效的时候,可以尝试让这个标签浮动,然后再定位 10.盒子模型 html中所有可见的标签都是一个盒子模型:包括长和宽决定的内容的大小,padding,border,margin四个部分组成 其中内容,padding,border是可见的部分,margin不可见 内容:设置width和height影响的就是内容部分的大小.添加子标签,添加内容都是放在内容部分的 padding:定义元素边框与元素内容之间的空间，即上下左右的内边距。 padding:10px 5px 15px 20px; 上填充是 10px 右填充是 5px 下填充是 15px 左填充是 20px border:边框,border:宽度 样式 颜色 样式:solid(实线)/dashed(虚线)/dotted(点划线)/double(双线) margin:外边距,是border外的区域","categories":[],"tags":[]},{"title":"AJAX","slug":"JQuery,AJAX","date":"2018-10-05T16:00:00.000Z","updated":"2018-10-06T09:30:18.077Z","comments":true,"path":"2018/10/06/JQuery,AJAX/","link":"","permalink":"http://yoursite.com/2018/10/06/JQuery,AJAX/","excerpt":"","text":"AJAX 是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。 1234567891011121314151617181920212223AJAXAJAX 是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。Asynchronous-异步请求(没有中断浏览器的用户体验)JavascriptAndXML-extensible markup language异步请求拿到的数据是JSON----&gt;通过DOM操作对页面进行局部刷新异步加载数据 + 局部刷新页面API应用程序编程接口appliciation programming interface$.getJSON(url,function(jsonObj)&#123;&#125;)jsonObj是一个json对象,jsonObj浏览器给的回调函数不会自己调,别人会调function()&#123;&#125;里写返回数据后要做的操作jsonObj相当于evtHTTP响应状态码2xx成功3xx重定向 401未授权403被禁用405请求方式不对5xx服务器出问题 12345678910111213141516171819202122232425262728293031323334jQuery jQuery 是一个 JavaScript 库,极大地简化了 JavaScript 编程。 write less do more jQuery 的功能概括:解决了浏览器兼容性问题,封装了常用的操作引入jQuery 1.使用自己项目中的jQuery.min.js 2.使用CDN服务器上的jQuery文件 通过网站www.bootcdn.cn下载jQuery,保存到网页的同一目录下,就可以使用$函数的四种用法 1.$函数的参数是一个函数-传入的函数是页面加载完成之后执行的回调函数 2.$函数的参数是选择器字符串-获取页面上的标签并且转成jQuery对象 为什么要获取jQuery对象-因为jQuery对象有更多封装好的方法可供调用 绑定/反绑定事件:on()/off()/one() 获取/修改标签内容:text()/html() 有参数是修改,没有是获取 获取/修改标签属性:attr(name,value) 添加子节点:append后面()/prepend前面() 删除/清空节点:remove()/empty() 修改样式表:css(&#123;&apos;color&apos;:&apos;red&apos;,&apos;font-size&apos;:&apos;18px&apos;&#125;)修改多组样式 获取父节点:parent() 获取子节点:children() 获取兄弟节点:prev()/next() 3.$函数的参数是标签字符串-创建标签(加尖括号)并且返回对应的jQuery对象 4.$函数的参数是原生JS对象-将原生JS对象转换成jQuery对象 jQuery 选择器$(&quot;*&quot;) 选取所有元素$(&quot;ul li:first-child&quot;) 选取每个 &lt;ul&gt; 元素的第一个 &lt;li&gt; 元素$(&quot;[href]&quot;) 选取带有 href 属性的元素$(&quot;a[target=&apos;_blank&apos;]&quot;) 选取所有 target 属性值等于 &quot;_blank&quot; 的 &lt;a&gt; 元素div p 是div包含pdiv&gt;p 父级是div的pdiv+p div和p紧挨着div,p 二者并列","categories":[],"tags":[]},{"title":"HTML语法","slug":"html","date":"2018-10-05T16:00:00.000Z","updated":"2018-10-06T09:59:04.350Z","comments":true,"path":"2018/10/06/html/","link":"","permalink":"http://yoursite.com/2018/10/06/html/","excerpt":"","text":"HTML结构标准中规定了网页上能够显示的内容如文字,图片,视频等 1.概述 123HTML是结构标准, CSS是表现标准, JS是行为标准HTML结构标准中规定了网页上能够显示的内容,如文字,图片,视频等,CSS是表现标准规定网页内容的布局和样式,JS行为标准规定网页的内容的动态变化. 2.HTML 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182HTML(超文本标记语言),广义的h5指的是html5+CSS3+JS,html文件结构由不同的标签组成,标签的分类有双标签和单标签两种,标签里面可以是任何内容,大小写不敏感&lt;标签名 属性名1=属性值1&gt;标签内容&lt;/标签名&gt;空格符:&amp;nbsp;强制换行:&lt;br /&gt;&lt;h1&gt;我是标题1&lt;/h1&gt;&lt;p&gt;段落&lt;/p&gt;&lt;b&gt;加粗&lt;/b&gt;&lt;strong&gt;加粗,强调&lt;/strong&gt;&lt;i&gt;倾斜&lt;/i&gt;&lt;em&gt;倾斜,强调&lt;/em&gt;水平线单标签&lt;hr /&gt;列表标签:ul,ol,dl ul:无序列表 ol:有序列表 dl:自定义列表图片标签单标签&lt;img&gt;,属性:src(图片地址),title(图片标题),alt(加载失败的信息)超链接标签&lt;a&gt; &lt;/a&gt;,属性:href(跳转目标对应的地址),target(跳转方式),默认是当前页面,设置为_blank是在新的页面去刷新表格标签table标签:表格整体(一个table标签代表一个表格)tr标签:行(一个tr标签代表表格中的一行)td标签:单元格(一个td代表一个单元格)th标签:表头属性 a.border:设置表格边框的宽度(table属性) b.bordercolor:设置边框的颜色(table属性) c.background:设置背景图片 d.bgcolor:设置背景颜色(可以作用于table\\tr\\td) e.cellspacing:设置单元格之间的间隙(默认是1) f.cellpadding:设置内容和单元格之间的间距 g.width:一般作用于某一个单元格,影响的是这个单元格对应的那一列 h.height:一般作用于行 i.align:设置对齐方式(可以作用于table\\tr\\td) 作用于table,让整个表格在浏览器中居中 作用于tr/td,让内容在单元格中居中细线表格是设置table属性cellspacing=1,bgcolor黑色,tr的bgcolor白色复杂表格的制作过程:先确定表格中最多多少行,然后再数每一行有多少个单元格,然后确定每个单元格是否有合并现象,如果单元格有行的合并就设置单元格的rowspan属性如果有列的合并就设置单元格的colspan属性 表单标签:form标签,用来获取input标签中的数据,通过属性method对应的方式发送请求,发给属性action对应的请求input标签单标签,type属性决定标签的形式(1)text是文本输入框属性:name,value,placeholder(占位符,提示信息),maxlength(约束字符个数)提交input中的数据给服务器的时候,是以name值=value值来提交的(2)password是密码输入框(3)radio是单选按钮name属性:如果多个单选按钮只选一个,那么这些按钮对应的name值必须一致value属性:设置为这个按钮选中后提交对应的值checked属性:设置默认选中(4)checkbox是复选按钮 同一组的数据对应的name值一样(5)button是普通按钮 value属性:按钮上显示的内容(6)submit是提交按钮(7)reset是重置按钮 将input标签的值回到初始状态(8)file是文件域select标签:下拉菜单,菜单中的选项通过option列举可以通过optgroup标签对下拉菜单进行分组,通过label属性对分组进行命名textarea标签:多行文本域name:提交的数据对应的名字 rows:默认一屏的行数 cols:默认的列数 placeholder:设置占位符 disabled:禁用 maxlength:约束能输入的最大的字符个数button标签 按钮div标签是空白标签,用来分组,div是块级标签,span是行内标签块级标签:一个标签占一行 h1-h6, p, 列表标签(ul,ol,dl), table,hr等 行内标签:一行可以放多个行内标签 img, a,input,select,textarea等","categories":[],"tags":[]},{"title":"set up git","slug":"setgit","date":"2018-10-05T16:00:00.000Z","updated":"2018-10-06T04:37:06.024Z","comments":true,"path":"2018/10/06/setgit/","link":"","permalink":"http://yoursite.com/2018/10/06/setgit/","excerpt":"","text":"如何设置git 本地: 首先进入到那个文件夹里面 git init-将文件夹初始化成git仓库 git add -将文件添加到暂存区 git status-查看暂存区的状态 git config –global user.name “”用户名git config –global user.email “”邮箱 git commit -m”注释” github: git clone-将服务器上的项目(仓库)克隆到本地 先在本地实施版本控制 git push–将代码推送到服务器(上传代码)-分享自己的成果 要输入注册github的用户名和密码 git pull -将服务器代码同步到本地(下载)-看到他人更新 其他的操作: 总结工作区–暂存区(缓存区)–仓库 git reset HEAD - 将文件从暂存区移除 git checkout – - 将暂存区文件恢复到工作区 在文件夹里误删除了 git commit -m”注释” - 将暂存区的内容提交到本地仓库 git log - 查看提交日志(只能查看当前版本之前的版本)git reflog - 查看日志(所有的版本) git reset – hard HEAD^-回到上一个版本git reset – hard - 回到指定版本 –hard 工作区和暂存区完全一致","categories":[],"tags":[]}]}